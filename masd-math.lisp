(in-package #:masd)

;; maxkeresok
(defmacro most-rel-seq (sequence rel)
  (oncesyms (sequence)
	    (gensyms (rec s m) 
		     `(labels ((,rec (,s ,m)
				 (if ,s
				     (if (funcall ,rel (car ,s) ,m)
					 (,rec (cdr ,s) (car ,s))
					 (,rec (cdr ,s) ,m))
				     ,m)))
			(,rec (cdr ,sequence) (car ,sequence))))))
(defun max-seq (sequence &key (test #'>))
  (most-rel-seq sequence test))
(defun min-seq (sequence &key (test #'<))
  (most-rel-seq sequence test))


(defmacro max-list (lis)
  `(apply #'max ,lis))
(defmacro min-list (lis)
  `(apply #'min ,lis))

(defun sqr (n)
  (expt n 2))
(defmacro summa (sequence)
  `(apply #'+ ,sequence))
(defmacro summa-abs (sequence)
  (gensyms (s)
    `(iter (for ,s in ,sequence)
	   (summing ,s))))
(defmacro summa-sqr (sequence)
  (gensyms (s)
    `(iter (for ,s in ,sequence)
	   (summing (sqr ,s)))))
(defmacro product (sequence)
  `(apply #'* ,sequence))
(defmacro avg (sequence)
  (oncesyms (sequence) 
    `(/ (summa ,sequence) (list-length ,sequence))))
(defmacro avg-sequence (sequence-list)
  (oncesyms (sequence-list)
    (let ((r (gensym )))
      `(apply #'mapcar (lambda (&rest ,r) (avg ,r)) ,sequence-list))))

(defun arithmetic-mean (&rest numbers)
  (/ (apply #'+ numbers) (list-length numbers)))
(defun geometric-mean (&rest numbers)
  (expt (apply #'* numbers) (/ 1 (list-length numbers))))
(defun argeom-mean (&rest numbers)
  (/ (+ (apply #'arithmetic-mean numbers) (apply #'geometric-mean numbers)) 2))


(defun -sequences (&rest sequences)
  (apply #'mapcar #'- sequences))
(defun +sequences (&rest sequences)
  (apply #'mapcar #'+ sequences))
(defun *sequences (&rest sequences)
  (apply #'mapcar #'* sequences))
(defun /sequences (&rest sequences)
  (apply #'mapcar #'/ sequences))

(defun -sequence (sequence0 sequence1)
  (iter (for s0 in sequence0)
	(for s1 in sequence1)
	(collect (- s0 s1))))
(defun +sequence (sequence0 sequence1)
  (iter (for s0 in sequence0)
	(for s1 in sequence1)
	(collect (+ s0 s1))))
(defun /sequence (sequence divisor)
  (iter (for s in sequence)
	(collect (/ s divisor))))
(defun *sequence (sequence multiplier)
  (iter (for s in sequence)
	(collect (* s multiplier))))


(defun norm (sequence n)
  (expt (iter (for s in sequence) 
	      (summing (expt s n)))
	(/ 1.0 n)))
(defun distance (sequence0 sequence1 &key (norm 2))
  (norm (-sequence sequence0 sequence1) norm))
(defun norm-sequence (sequence)
  (let ((sum (summa-abs sequence)))
    (iter (for s in sequence)
	  (collect (/ s sum)))))
(defun norm-direction (sequence)
  (/sequence sequence (norm sequence 2)))

(defun scalar-product (sequence0 sequence1)
  (iter (for l0 in sequence0)
	(for l1 in sequence1)
	(summing (* l0 l1))))

(defun cos-of-sequences (sequence0 sequence1)
  (scalar-product (norm-sequence sequence0) (norm-sequence sequence1)))
(defun angle-of-sequences (sequence0 sequence1)
  (acos (cos-of-seqences sequence0 sequence1)))
  

;; 
(defmacro 1/+ (value &optional +val)
  (if +val
      `(/ 1.0 (+ ,+val ,value))
      `(/ 1.0 (+ 1.0 ,value))))

(defmacro un1/+ (value &optional +val)
  (if +val
      `(- (/ ,+val ,value) 1)
      `(- (/ 1.0 ,value) 1)))
		     
(defun statistics (sequence)
  (let ((ss (sort  (iter (for g in (group sequence #'=))
			 (collect (list (list-length g) (car g))))
		   (lambda (g0 g1) (< (cadr g0) (cadr g1))))))
    (let ((sum (iter (for (p v) in ss) (summing p))))
      (iter (for (p v) in ss)
	    (collecting (list (/ p sum) v))))))